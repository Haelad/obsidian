





# в классе используется reverse_lazy а в функциях можно reverse

  

# используется для отображения списков в шаблоне

class HomeView(ListView):

    # указывается модель - дб

    # по умолчанию из модели берутся все записи, для того что бы воспользоваться конкретными записями нужно использовать функцию `def get_queryset`

    model = ContextData

    # указывается шаблон, по умолчанию он будет искать шаблон по такому запросу: <имя приложения>/<имя модели>_list.html

    template_name = "home.html"

    # указывается имя переменной внутри шаблона, по умолчанию он будет его искать по такому имени {% for _ in `object_list` %}

    context_object_name = 'menu'

    # при пустом списке будет вызваннна ошибки 404

    allow_empty = False

    # может содержать только те данные которые "уже созданны (статистические) данные", то есть он не поддерживает "динамические данные"

    extra_context = {

        'title': 'This is home page@!!@#!#',

        'logo': 'lamou'

    }

    # используется для получения динамических данных

    # !!при созданние функции django будет ждать context (если ей ничего не возвращать) что может вызвать ошибки

    def get_context_data(self, **kwargs: Any) -> dict[str, Any]:

        context = super().get_context_data(**kwargs)

        context['menu'] = 'logo', 'О нас', 'Войти', 'Обратная связь'

        return context

    # используется для получения выборочных данных

    # возвращает список элементов

    # def get_queryset(self) -> QuerySet[Any]:

    #     ...

# DetailView 
предполагает работу с одним единственным объектом

class ShowPost(DeleteView):

    # model

    # template_name

    # из маршрутизатора будут искаться по определенным данным в url (по умолчению: path(/<slug: `slug`> или /<pk: `pk`>) )

    # для переопределенния url переменной используются артибуты:

    # slug_url_kwarg = "somthings_slug"

    # pk_url_kwarg = "somthings_pk"

    # указывается имя переменной внутри шаблона, по умолчанию он будет его искать по такому имени {% for _ in `object` %}

    # context_object_name =

  

    # используется для отображения конкретного объекта

    # def get_object(self, queryset: QuerySet[Any] | None = ...) -> Model:

    #       не кое выражение ...

    #     return get_object_or_404(ContextData.pk == 1)

     ...

    # используется для автоматизации отображения и обработки html форм

class SomeShit(FormView):

    # !! по умолчанию в шаблон передает переменную с именем form

    # ссылается на класс формы

    # form_class = SomthingForm

    # template_name

    # определяет url адрес на который мы переадресовываем пользователя после успешной отправки и обработки формы

    # success_url = reverse_lazy('home') не выстраивает маршрут сразу же, а только когда это необходимою.  не исопльзоват в классах - reverse('home') выстраивает маршрут, возвращет полный маршрут по имени маршрутизатора.

    # вызывается после того как будут проверенны все поля формы, то есть если все форма была заполнена верна

    # def form_valid(self, form):

    #     # form ссылается на объект класса формы, который мы прописали выше

    #     form.save()

    #     return super().form_valid(form)

    ...