---
Framework: Django
tags:
  - Программирование
  - Django
  - Python
дата создания: 2024-12-14
время: 2024-12-17T16:03:00
---

*******


# Ручное кеширование 

Ручное кеширование подразумевает под собой кеширование определенных перемен в ручную с прописанной логикой.

## плюсы:
- гибок в настройке 
- Настройка политики кэширования:
	 Вручную можно реализовать различные стратегии управления кэшом, такие как «LRU» (Least Recently Used), «LFU» (Least Frequently Used) или другие алгоритмы, которые могут быть оптимальны для конкретного случая.

## минусы:
 - Сложность разработки и поддержки:
	Это может быть ключевым минусом ручного кэширования, ведь если допустить ошибку или недочет в программе, это может привести к серьёзным проблемам : ошибкам валидации, синхронизации данных, обработки исключений и т. д.


### Заключение:

Ручное кэширование может быть полезным в тех случаях, когда требуется максимальный контроль над процессом, и когда автоматизированные решения не подходят. Однако оно требует значительных усилий на этапе разработки и поддержки, и может быть менее эффективным по сравнению с готовыми решениями, особенно в больших или сложных системах.




# Кэширование с использованием Middleware 

**Middleware автоматически кэширует все страницы сайта.**

Django предоставляет два основных middleware для кэширования:

1. **`UpdateCacheMiddleware`** — отвечает за обновление кэша для каждого запроса.
2. **`FetchFromCacheMiddleware`** — проверяет, есть ли кэшированная версия страницы, и если она существует, извлекает её и возвращает пользователю, минуя остальные middleware и представления.

>[!note] доп информация
	Кэширование всего сайта подразумевает под собой кеширование ответов GET и HEAD со статусом 200, если заголовки запроса и ответа это допускают.
	Ответы на запросы для одного и того же URL с разными параметрами запроса считаются уникальными страницами и кэшируются отдельно


# Плюсы и минусы
## плюсы:
### 1. Простая настройка 
- автоматизирует кэширование сайта делая его удобным решением для больших и малых проектов 
### 2. Гибкие настройки
- позволяет настроить различные параметры кэша под свои нужды не заморачиваясь слишком сильно
### 3. Оптимизация работы с кэшем на уровне страниц
- обеспечивают кэширование на уровне целых страниц, включая как HTML, так и другие данные, такие как статические файлы.

## минусы:
### 1. Отсутствие валидности кэша
- из-за автоматизации кэширования сайта нельзя на уровне Middleware  валидировать данные, из-за этого кэш может как устареть, загрязниться, так и иметь в себе неверные данные
###  2.  Отсутствие гибкости в кэшировании данных
- Не все данные можно кэшировать (не имея дальнейших проблем с ними), например, те, которые зависят от конкретного пользователя.
- Так же кэширование будет работать только со страницами HTML, если нужно кэшировать динамические блоки или фрагменты страницы, то этот способ не подойдет
### 3. сложность настройки
- хоть автоматизация и настройка кэша для сайта удобная, но для некоторых проектов она может стать сложной особенно там, где требуется более гибкая логика кэширования сайта


# Настройка кэширования на уровне представлений

В Django для этого используется декоратор `cahce_page`.

Пример:
```Python
from django.views.decorators.cache import cache_page
from django.shortcuts import render

@cache_page(60 * 15)  # Кэшировать страницу на 15 минут
def my_view(request):
    context = {
        'some_data': 'Hello, World!',
    }
    return render(request, 'my_template.html', context)
```

>cahce_page на уровне views сохраняет полный ответ (включая HTML-контент) в кэш на заданный промежуток времени.

Кэш при этом сохраняется в бекенде кэша который указан в `settings.py`
```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': '127.0.0.1:11211',
    }
}
```
>в нашем случае это хост

Так же можно кэшировать представление из url
```python
from django.views.decorators.cache import cache_page
urlpatterns = [
    path("foo/<int:code>/", cache_page(60 * 15)(my_view)),
```
>суть не меняется

>[!note] доп информация
	Принцип работы с данными схож с использованием Middleware, но настройка у декоратора более тонкая нежели чем в Middleware

!!!optional keyword argument for cahce_page:

sssometing

# Плюсы и минусы
## плюсы:
### 1. Простая настройка и Гибкая настройки
-  позволяет применить декоратор к представлению легко и просто 
- позволяет настроить представления, которые нам нужны 
- позволяет настроить TTL
### 2. Оптимизация работы с кэшем на уровне страниц
- обеспечивают кэширование на уровне целых страниц, включая как HTML, так и другие данные, такие как статические файлы.

## минусы:

### 1. Невозможность кэшировать динамические данные
- Не подойдет для персонализированных страниц, так как кэшированные страницы могут быть показаны неверному пользователю.
### 2. Требуется тщательное управление кэшем
- Нужно правильно настроить очистку или обновление кэша, чтобы избежать использования устаревших данных.


Используется если нужна более тонкая настройка кэширования представлений

# Настройка Кэширования Шаблонов

Если нам требуется более гибкая настройка шаблона кэша, то в Django используется для этого тэг `{% cache %}`

Тег шаблона `{% cache %}` кэширует содержимое блока на заданное время. 
Он принимает как минимум два аргумента: тайм-аут кэша в секундах и имя.

>[!note] Важно
 Фрагмент кэшируется навсегда, если тайм-аут равен `None`. 
 Имя будет принято как есть, не используйте переменную. Например:

```django
{% load cache %}
{% cache 500  sidebar %}
    .. sidebar ..
{% endcache %}
```

## Параметры Тэга

`500` - это время в секундах
`sidebar` - это имя кэша

### дополнительные аргументы

Так же тег шаблона может принимать еще один аргумент - дополнительные аргументы

Например, вам может понадобиться **отдельная кэшированная копия боковой панели, использованной** в предыдущем примере, **для каждого пользователя вашего сайта**. 
Сделайте это, передав один или несколько дополнительных аргументов, которые могут быть переменными с фильтрами или без них, в тег шаблона `{% cache %}` для уникальной идентификации фрагмента кэша:

```django
{% load cache %}
{% cache 500 sidebar request.user.username %}
    .. sidebar for logged in user ..
{% endcache %}
```


### [[USE_I18N]]

Если [`USE_I18N`](https://docs.djangoproject.com/en/5.1/ref/settings/#std-setting-USE_I18N) установлено в `True`, кэш промежуточного программного обеспечения для каждого сайта будет [соблюдать активный язык](https://docs.djangoproject.com/en/5.1/topics/cache/#i18n-cache-key). Для тега шаблона `cache` вы можете использовать одну из [переводно-специфичных переменных](https://docs.djangoproject.com/en/5.1/topics/i18n/translation/#template-translation-vars), доступных в шаблонах, чтобы достичь того же результата:

```django
{% load i18n %}
{% load cache %}

{% get_current_language as LANGUAGE_CODE %}

{% cache 600 welcome LANGUAGE_CODE %}
    {% translate "Welcome to example.com" %}
{% endcache %}
```


### Использование тайм-аута в виде переменной

установление параметра таймауту:
```python
example
```

Время ожидания кэша может быть переменной шаблона, пока переменная шаблона разрешается в целочисленное значение. 

Например, если переменная шаблона `my_timeout` установлена ​​в значение `600`, то следующие два примера эквивалентны:
```django
{% cache 600 sidebar %} ... {% endcache %}
{% cache my_timeout sidebar %} ... {% endcache %}
```

Эта функция полезна для избежание повторений в шаблонах. Вы можете установить тайм-аут в переменной в одном месте и повторно использовать это значение.



### установление параметра template_fragments

По умолчанию тег кэша попытается использовать кэш под названием «template_fragments». 

Если такого кэша не существует, он вернется к использованию кэша по умолчанию **(Backend cahce).** Вы можете выбрать альтернативный бэкэнд кэша для использования с аргументом ключевого слова `using`, который должен быть последним аргументом тега.

```django
{% cache 300 local-thing ...  using="localcache" %}
```

>Указание имени кэша, которое не настроено, считается ошибкой.

## template_fragment_key

`django.core.cache.utils.make_template_fragment_key(_fragment_name_, _vary_on=None_)`

Если вы хотите получить ключ кэша, используемый для кэшированного фрагмента, вы можете использовать `make_template_fragment_key`. 

Параметры:
`fragment_name` - это имя тега шаблона `cache`; 
`vary_on` — это список всех дополнительных аргументов, переданных тегу.

Эта функция может быть полезна для аннулирования или перезаписи кэшированного элемента, например:
```python
>>> from django.core.cache import cache
>>> from django.core.cache.utils import make_template_fragment_key
# cache key for {% cache 500 sidebar username %}
>>> key = make_template_fragment_key("sidebar", [username])
>>> cache.delete(key)  # invalidates cached template fragment
```

## Controlling cache: Using other headers

Другие проблемы с кэшированием — конфиденциальность данных и вопрос о том, где данные должны храниться в каскаде кэшей.

Обычно пользователь сталкивается с двумя типами кэшей: кэш собственного браузера (частный кэш) и кэш провайдера (публичный кэш). 

Публичный кэш используется несколькими пользователями и контролируется кем-то другим. Это создает проблемы с конфиденциальными данными — вы не хотите, чтобы, скажем, номер вашего банковского счета хранился в публичном кэше. Поэтому веб-приложениям нужен способ сообщать кэшам, какие данные являются частными, а какие — публичными.

Решение — указать, что кэш страницы должен быть «частным». Чтобы сделать это в Django, используйте декоратор представления [`cache_control()`](https://docs.djangoproject.com/en/5.1/topics/http/decorators/#django.views.decorators.cache.cache_control "django.views.decorators.cache.cache_control"). Пример:

```python
from django.views.decorators.cache import cache_control

@cache_control(private=True)
def my_view(request):
	...
```

Этот декоратор заботится об отправке соответствующего заголовка HTTP за кулисами.


Обратите внимание, что настройки управления кэшем «private» и «public» являются взаимоисключающими. Декоратор гарантирует, что директива «public» будет удалена, если должна быть установлена ​​«private» (и наоборот). Примером использования двух директив может быть сайт блога, который предлагает как частные, так и публичные записи. Публичные записи могут кэшироваться в любом общем кэше. Следующий код использует [`patch_cache_control()`](https://docs.djangoproject.com/en/5.1/ref/utils/#django.utils.cache.patch_cache_control "django.utils.cache.patch_cache_control"), ручной способ изменения заголовка управления кэшем (он вызывается внутренне декоратором [`cache_control()`](https://docs.djangoproject.com/en/5.1/topics/http/decorators/#django.views.decorators.cache.cache_control "django.views.decorators.cache.cache_control")):

```python
from django.views.decorators.cache import patch_cache_control
from django.views.decorators.vary import vary_on_cookie


@vary_on_cookie
def list_blog_entries_view(request):
    if request.user.is_anonymous:
        response = render_only_public_entries()
        patch_cache_control(response, public=True)
    else:
        response = render_private_and_public_entries(request.user)
        patch_cache_control(response, private=True)

    return response
```


(Если вы _используете_ промежуточное ПО кэширования, оно уже устанавливает `max-age` со значением параметра [`CACHE_MIDDLEWARE_SECONDS`](https://docs.djangoproject.com/en/5.1/ref/settings/#std-setting-CACHE_MIDDLEWARE_SECONDS). В этом случае пользовательский `max_age` из декоратор [`cache_control()`](https://docs.djangoproject.com/en/5.1/topics/http/decorators/#django.views.decorators.cache.cache_control "django.views.decorators.cache.cache_control") будет иметь приоритет, и значения заголовков будут объединены правильно.)
Любая допустимая директива ответа `Cache-Control` допустима в `cache_control()`. Вот еще несколько примеров:

- `no_transform=True`
    
- `must_revalidate=True`
    
- `stale_while_revalidate=num_seconds`
    
- `no_cache=True`
    

Полный список известных директив можно найти в [реестре IANA](https://www.iana.org/assignments/http-cache-directives/http-cache-directives.xhtml) (обратите внимание, что не все из них применяются к ответам).

Если вы хотите использовать заголовки для полного отключения кэширования, [`never_cache()`](https://docs.djangoproject.com/en/5.1/topics/http/decorators/#django.views.decorators.cache.never_cache "django.views.decorators.cache.never_cache") — это декоратор представления, который добавляет заголовки, чтобы гарантировать, что ответ не будет кэшироваться браузерами или другими кэшами. Пример:

``` python
from django.views.decorators.cache import never_cache

@never_cache
def myview(request): ...
```
