Background workers 

Что такое "Background workers"?

Background workers - это определенная единица (программа), которая выполняет задачи на "заднем плане", то есть что бы не нагружать основной сервер, различными задачами, разной сложности пишется Background workers 





# Конфигурация 


Есть несколько способов изменить конфигурацию celery 

конфигурация доступна по такому пути: `app.conf`

ее можно менять напрямую 
`app.conf.enable_utc = True`


или вызвав метод `update()`
```python 
app.conf.update(
    enable_utc=True,
    timezone='Europe/London',
    )
```
>просто через метод update обновляем ключи

>[!Note]
>Конфигурация состоит из нескольких словарей, к которым обращаются по порядку:
>	1. По изменениям, внесенным во время выполнения.
>	2. По модулю конфигурации (если такой есть)
>	3. По модулю конфигурации по умолчанию
>
> Вы даже можете добавить новые источники по умолчанию, используя метод `app.add_defaults()`


# Загрузка конфигурации


С помощью метода `config_from_object()` можно загрузить конфигурацию из объекта представляющего собой конфигурацию

>[!note]
>Любая конфигурация записанная до вызова функции `config_from_object()` будет стерта при вызове функции

# 1. Пример 

#### Используя имя модели 

Метод `config_from_object()` может принять полное имя модуля Python и даже его атрибута

```python
from celery import Celery

app = Celery()
app.config_from_object('celeryconfig')
```
>`celeryconfig` будет выглядеть так:

`celeryconfig.py`:
```python
enable_utc = True
timezone = 'Europe/London'
```
>приложение будет использовать его то тех пор пока возможен импорт модуля


# 2.Пример

#### Используя объект модели

```python
import celeryconfig

from celery import Celery

app = Celery()
app.config_from_object(celeryconfig)

```


# 3.Пример

#### Используя Класс или объекта модуля 

```python 
from celery import Celery

app = Celery()

class Config:
    enable_utc = True
    timezone = 'Europe/London'

app.config_from_object(Config)

```
>        ИЛИ
```python
app.config_from_object('module:Config')
```


# Загрузка конфигурации используя среду

метод `config_from_envva()` получает имя модуля конфигурации из переменной содержащие в себе среду

```python
import os
from celery import Celery

#: Set default configuration module name
os.environ.setdefault('CELERY_CONFIG_MODULE', 'celeryconfig')

app = Celery()
app.config_from_envvar('CELERY_CONFIG_MODULE')
```

# Cкрытая конфигурация 

Если нашей задачей стоит вывести, отладить или попросту отфильтровать информацию, нам понадобится такие функции:


# `humanize()`
<h3>следует знать что:</h3>
**1. 
	 Метод возвращает конфигурацию как табличные строки.
	
**2. 
	Метод будет включать в себя, только те изменения, которые были по умолчанию.
	
**3.
	Можно включить в себя встроенные изменения параметром `with_defaults argument`.

#### Синтаксис:

`app.conf.humanize(with_defaults=False, censored=True)`

#### Параметры:

описание синтаксиса параметров функции
- `with_defaults` - пояснение
- `censored` - пояснение


### пример с кодом:
```python


app.conf.humanize(with_defaults=False, censored=True)


```


> [!warning]
>Параметр конфигурации будет подвергаться цензуре, если имя содержит любую из этих подстрок:
 `API`, `TOKEN`, `KEY`, `SECRET`, `PASS`, `SIGNATURE`, `DATABASE`
>


# `table()`
<h3>следует знать что:</h3>
**1. 
	Метод возвращает конфигурацию как словарь.
	
**2. 
	Метод будет включать в себя, только те изменения, которые были по умолчанию.
	
**3.
	Можно включить в себя встроенные изменения параметром `with_defaults argument`.

#### Синтаксис:

`app.conf.table(with_defaults=False, censored=True)`

#### Параметры:

описание синтаксиса, параметров функции
- `object` - пояснение
- `object` - пояснение



### пример с кодом:
```python

app.conf.table(with_defaults=False, censored=True)

```
>комментарий к коду


>[!note]
>Обратите внимание, что Celery не сможет удалить всю конфиденциальную информацию, поскольку он просто использует регулярное выражение для поиска часто используемых ключей. 
>Если вы добавляете пользовательские настройки, содержащие конфиденциальную информацию, вам следует назвать ключи, используя имя, которое Celery идентифицирует как секретное.


> [!warning]
>Параметр конфигурации будет подвергаться цензуре, если имя содержит любую из этих подстрок:
 `API`, `TOKEN`, `KEY`, `SECRET`, `PASS`, `SIGNATURE`, `DATABASE`



# Laziness

Экземпляры приложения ленивые, это означает, что он не будет использоваться до тех пор, пока он действительно не понадобится.

Для того что бы создать экземпляр приложения нужно:
	1. Создайте экземпляр логических часов, используемый для событий.  
	2. Создайте реестр задач.  
	3. Установить себя в качестве текущего приложения (но не в том случае, если аргумент set_as_current был отключен)  
	4. Вызовите обратный вызов `app.on_init()` (по умолчанию ничего не делает).
  

  
>[!notice]
>Декоратор `app.task` не создают задачу во время определения объекта, вместо этого он откладывает создания задача либо при ее использовании, либо после завершения работы приложения 
  
```python
>>> @app.task
>>> def add(x, y):
...   return x + y

>>> type(add)
<class 'celery.local.PromiseProxy'>

>>> add.__evaluated__()
False

>>> add        # <-- causes repr(add) to happen
<@task: __main__.add>

>>> add.__evaluated__()
True
```
>Завершение приложения происходит либо явно путем вызова `app.finalize()`, либо неявно путем доступа к атрибуту **app.tasks**.

Finalizing Завершение объекта будет:  
  
1. Копировать задачи, которые должны быть разделены между приложениями  
>По умолчанию задачи являются общими, но если общий аргумент декоратора задач отключен, задача будет частной для приложения, к которому она привязана.  
  
2. Выразит все декораторы ожидающих задач.  
  
3. Убедится, что все задачи привязаны к текущему приложению.  
>Задачи привязаны к приложению, поэтому они могут считывать значения по умолчанию из конфигурации.


Абстрактные задачи  
  
Все задачи, созданные с помощью декоратора app.task(), будут наследоваться от базового класса Task приложения.  
  
Вы можете указать другой базовый класс, используя аргумент base:
```python
@app.task(base=OtherTask):
def add(x, y):
    return x + y
```

Чтобы создать собственный класс задач, вы должны наследовать нейтральный базовый класс: celery.Task.

```python 
from celery import Task

class DebugTask(Task):

    def __call__(self, *args, **kwargs):
        print('TASK STARTING: {0.name}[{0.request.id}]'.format(self))
        return self.run(*args, **kwargs)
```
