****
Операции в Redis являются ***Атомарными***, что означает, что **либо вся операция будет выполнена, либо ни одна из них не будет выполнена**.

# Строки

#### SET 
##### устанавливает какое либо значение ключу   
```R
127.0.0.1:6379> SET Key "hello"
OK
127.0.0.1:6379> SET SecondKey "world"
```

#### GET 
##### получает значение по ключу
```R
127.0.0.1:6379> GET Key
"hello"
127.0.0.1:6379> GET SecondKey
"world"
```

###### Если значение отсутствует мы получим значение - nil
```R
127.0.0.1:6379> GET UnkwonKey
(nil)
```

#### EXISTS 
##### возвращает 1 если запись с данным ключом существует или 0 если отсутствует
```R
127.0.0.1:6379> EXISTS Key
(integer) 1

127.0.0.1:6379> EXISTS foo
(integer) 0
```

#### FLUSHALL 
##### Удаляет все данные в текущем сеансе
```R
127.0.0.1:6379> FLUSHALL
```

#### GETSET

##### Команда возвращает текущее значение и устанавливает новое. Используется для атомарного управления данными:

```R
127.0.0.1:6379> SET foo "hello"
OK
127.0.0.1:6379> GETSET foo "world"
"hello"
127.0.0.1:6379> GET foo
"world"
```

#### DEL 
##### удаляет данные по ключу
```R
127.0.0.1:6379> DEL Key
DEL will delete keys, it may cause high latence when the value is big.
Do you want proceed (y/n): y
Your Call!!
(integer) 1
127.0.0.1:6379> GET Key
(nil)
```

#### KEYS  
##### для того что бы посмотреть список ключей которые по указанному шаблону
```R
127.0.0.1:6379> KEYS *
```
!!! предупреждение:
В больших проектах команда KEYS * не используется из за большого риска краша redis

#### INCR / DECR

Инкремент / декримент. Значение ключа `integer`, хотя в базе храниться все равно строка, можно увеличить или уменьшить на `1`. Если использовать команду `INCR` с несуществующем значением то создаться новый ключ со значением 1:
```R
127.0.0.1:6379> SET foo 1
OK
127.0.0.1:6379> INCR foo
(integer) 2
127.0.0.1:6379> INCR foo
(integer) 3
127.0.0.1:6379> DECR foo
(integer) 2
```


#### INCRBY 

##### увеличивает число на определенное число которые мы указываем
```R
127.0.0.1:6379> SET num 1
Ok
127.0.0.1:6379> INCRBY num 3
integer(4)
```

#### DECRBY 
##### уменьшает число на определенное число которые мы указываем
```r
127.0.0.1:6379> SET num 4
Ok
127.0.0.1:6379> DECRBY num 3
integer(1)
```

# Списки

#### LPUSH - для того что бы добавить объект в список слева
```R
redis 127.0.0.1:6379> lpush test:1:messages "Hello, user!"
(integer) 1                                
```

#### LRANGE - для того что бы получить объекты списка, через срез индексов списка слева.
```R
redis 127.0.0.1:6379> lrange test:1:messages 0 2
1) "Hello, user!"                              
2) "Hello, world!"                               
3) "Wow!" 
```

#### LPOP - для того что бы вынуть слева объект из списка .
```R
redis 127.0.0.1:6379> lpop test:1:messages     
"Hello, world!"
```

#### LLEN - для того что бы посмотреть длину списка
```R
redis 127.0.0.1:6379> llen test:1:messages     
(integer) 3       
```

#### LMOVE - для того что бы переместить объект из одного списка в другой


#### Аналогичные команды `RPUSH`, `RRANGE`, `RPOP`, `RMOVE` только для правой стороны.

# Множества 

#### SADD 

Для того что бы создать множество

```R
127.0.0.1:6379> SADD objects obj1
(integer) 1

127.0.0.1:6379> SADD objects obj1
(integer) 0
```

#### SMEMBERS

Для получения всех элементов множества 

```R
127.0.0.1:6379> SMEMBERS objects
1) "obj1"
```

#### SUNION

```
```
Используется для объединения множеств

#### SDIFF

```
```
возвращает только уникальные элементы выбранного множества, остальные удаляет?

#### SINTER 
```
```
возвращает общие элементы указанных множеств.

#### SPOP
```
```
удаляет и возвращает **случайный** элемент множества?



# Сортированные Множества

#### ZADD

Синтаксис
`ZADD "имя_ключа" "порядковое_число_упорядочивания_множества "значение`

Используется для создания множества

```R
127.0.0.1:6379> ZADD objects 1500 value1
(integer) 1
127.0.0.1:6379> ZADD objects 1600 value2
(integer) 1
127.0.0.1:6379> ZADD objects 1700 value3
(integer) 1
```

#### ZRANGE

Возвращает срез упорядоченных данных

```R
127.0.0.1:6379> ZRANGE objects 0 -1
1) "value1"
2) "value2"
3) "value3"
```

# Хеш таблицы

#### HSET - для создания хеш таблицы
```R
redis 127.0.0.1:6379> hset users:1 name "Andrew"             
(integer) 1
redis 127.0.0.1:6379> hset users:1 email "andrew@example.com"
(integer) 1      
```

#### HGET - для получения значений по конкретному ключу
```R
redis 127.0.0.1:6379> hget users:1 name          
"Andrew"  
```

#### HKEYS - для получения всех ключей 
```R
redis 127.0.0.1:6379> hkeys users:1                          
1) "name"                                                    
2) "email" 
```

#### HVALS - для получения всех значений 
```R
redis 127.0.0.1:6379> hvals users:1                         
1) "Andrew"                                                 
2) "andrew@example.com"    
```

#### HMGET - для получения нескольких значений по конкретным ключам

```
```
мы получим список атрибутов таблицы

#### HGETALL - для получения всех атрибутов и значений таблицы
```R
redis 127.0.0.1:6379> hgetall users:1                        
1) "name"                                               
2) "Andrew"                                            
3) "email"                                                  
4) "andrew@example.com"      
```

#### HINCRBY - для увеличения нынешнего атрибута на значение которое мы зададим
```R
redis 127.0.0.1:6379> hset users:1 test 1                    
(integer) 1                                                  
redis 127.0.0.1:6379> hincrby users:1 test 123               
(integer) 124   
```

#### HDEL - для удаления данных по ключу
```R
redis 127.0.0.1:6379> hdel users:1 test                      
(integer) 1  
```

# Время жизни данных

#### TTL - для того что бы посмотреть сколько осталось времени до удаления данных

```R
127.0.0.1:6379> SET foo 10 EX 10
OK
127.0.0.1:6379> TTL foo
(integer) 6
127.0.0.1:6379> TTL foo
(integer) 5
127.0.0.1:6379> TTL foo
(integer) 2
127.0.0.1:6379> TTL foo
(integer) -2
```
по умолчанию значение TTL будет принимать -1, то есть у них не ограниченное время

#### PERSIST 

Нужен для того что бы удалить период истечения срока действия ключа (TTL)

```R
127.0.0.1:6379> PERSIST foo
(integer) 1
127.0.0.1:6379> TTL foo
(integer) -1
127.0.0.1:6379> GET foo
"bar"
```
>  -1 значит что у переменной foo отсутствует время жизни

#### RENAME

Эта команда используется для переименования ключей на нашем сервере Redis:

```R
127.0.0.1:6379> RENAME foo foo2
OK
127.0.0.1:6379> GET foo
(nil)
127.0.0.1:6379> GET foo2
"bar"
```

#### EXPIRE - для того что бы задать TTL

```
```

#### SETEX - для того что сразу при создании данных установить время TTL

```R
127.0.0.1:6379> SET foo 10 EX 10
OK
```

#### Транзакции - pipelines

Транзакции в Redis это просто последовательное выполнение ранее записанных команд без возможности полноценного возвращения исходного состояния в случае ошибки исполнения.

С помощью команды `MULTI` можно начать запись команд. Далее введенные команды не исполняются а записываются в буфер. Это будет происходит до ввода команды на исполнения транзакции `EXEC`. Далее все ранее введенные команды будут исполнены один за другим. Команда `DISCARD` отмена записи команд транзакций. Если возникнет ошибка в процессе ввода команд вся транзакция не будет выполнена:

```R
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET obj1 value1
QUEUED
127.0.0.1:6379> SET obj2 value2
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) OK
127.0.0.1:6379> GET obj1
"value1"
```


# Механиз подписок PUS-SUB

Одно из основных преимуществ Redis от других хранилищ заключается в том, что в Redis есть механизм подписок. То есть Redis можно использовать как сервер сообщений.

Для того что бы подписаться на канал используется команда `SUBCRIBE`
```R
SUBSCRIBE имя_канала
```
Для того что бы отправить сообщения на канал используется команда `PUBLISH`

```r
PUBLISH имя_канала значение
```


Принцип работы:
Допустим один клиент подписывается на канал:

```r
SUBSCRIBE channel
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "channel"
3) (integer) 1
```

Другой клиент что то отправляет в этот канал:

```r
PUBLISH channel "hello world"
(integer) 1
```

И в этот момент первый клиент получит это сообщение:

```r
SUBSCRIBE channel
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "channel"
3) (integer) 1
1) "message"
2) "channel"
3) "hello world"
```


# Управление базами в Redis

https://hmarketing.ru/blog/redis/upravlenie-bazami/