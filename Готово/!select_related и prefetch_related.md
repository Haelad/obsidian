
>[!summary] Терминология.
><font color="#ff0000">жадная загрузка</font> - это когда ORM получает связанные данные **вместе с основными**, заранее формируя один объединённый SQL-запрос.
><font color="#ff0000">ленивая загрузка</font> - **Данные загружаются только в момент обращения к ним**.

# Методы select_related и prefetch_related.

| Метод                | Тип загрузки | Тип связи                    | Принцип работы                                                |
| -------------------- | ------------ | ---------------------------- | ------------------------------------------------------------- |
| `select_related()`   | Жадная       | `ForeignKey`, `OneToOne`     | Использует `JOIN` для объединения таблиц в одном SQL запросе. |
| `prefetch_related()` | Ленивая      | `ManyToMany`, обратные связи | Делает несколько запросов и объединяет результаты в Python.   |
>[!info] нужны для **оптимизации sql запросов**, путем **избегания одинаковых, множественных запросов** к СУБД


>[!note] синтаксис:
```python
MyModel.objects.all().select_related/prefetch_related('атрибут который связывает таблицы')
```

# Примеры

>[!example] Без оптимизации
>```python
>for book in Book.objects.all():
>    print(book.author.name)  # каждый раз новый запрос!
>```
>в этом случае Django выполняет **отдельный запрос к базе данных для каждого объекта `Book`**, чтобы получить автора. Если книг 100, то будет **101 запрос** (один для всех книг + по одному для каждого автора). Это неэффективно.

>[!attention] принцип выбора метода зависит от типа связи бд

>[!example] С оптимизацией
>```python
># С select_related
>for book in Book.objects.select_related('author'):
>   print(book.author.name)  # все авторы загружены заранее
>```
>Здесь Django использует **JOIN** и загружает данные из обеих таблиц **одним запросом**.  Поэтому при итерации данные уже есть в памяти, и дополнительных запросов не происходит.
