

``` python
from django.contrib import admin
from .models import MyModel

@admin.register(MyModel)
class WomenAdmin(admin.ModelAdmin):
	fields = 'поля которые мы хотим отобразить'
	exclude = 'поля которые мы НЕ хотим отобразить'
	list_display = 'Поля, которые будут отображаться в панели'
	list_display_links = 'Поля, которые будут отображаться как ссылки'
	list_editable = 'Поля, которые можно редактировать, но при этом не являются ссылкам"
	list_per_page = указывается количество отображаемых статей в панели 
	readonly_fields = ['указываем поля, которые отображаются, но не редактируются']
	ordering = ['поля по которым будет происходить порядок сортировки']
	verbose_name = 'служит для отображения полей в админ понели'
	action = ['отображает в поле с действиями']
	search_fields = ['название поля по которому будет происходиить поиск записей']
	list_filter = ['название поля по которому будет происходиить фильтрация поелй']
		# поле которое должно быть редактируемым, конфликтует с - readonly_fields
	prepopulated_fields = {'формирует поле': ('на основе списка полей', )}
	

	def set_pub(self, request, queryset):
		count = queryset.update(is_published=MyModel.Status.PUBLISHED)
		self.message_user(request, f'изменено {count} записей.')
	
	def set_draf(self, request)

```

![[Pasted image 20240709153954.png]]

Создание пользовательского поля

в admin.py

``` python
from django.contrib import admin
from .models import MyModel

@admin.register(MyModel)
class MyModelAdmin(admin.ModelAdmin):
	list_display = ('brief_info')
	
	@admin.display(description='Краткое описание')
	def brief_info(self, field: MyModel):
		return f'Описание {len(field.content)} символов'
		

```
>

вот что получилось
![[Pasted image 20240709161636.png]]


через два поля в ORM django можно обращаться к встроенным фильтрам или к записям  в другой Таблице `cat__name`