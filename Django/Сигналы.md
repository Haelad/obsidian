# Что это такое
Django предоставляет [набор встроенных сигналов](https://djangodoc.ru/3.2/ref/signals/) , позволяющих пользовательскому коду получать уведомления от самого Django об определенных действиях.

# Как работает
Вкратце, сигналы позволяют определенным  ***отправителям***  уведомлять группу ***получателей***  о том, что произошло какое-то действие. Они особенно полезны, когда одни и те же события могут интересовать несколько фрагментов кода.

# Список основных сигналов
-  `pre_save` и `post_save`
	- Отправляется до или после вызова [`save()`](https://djangodoc.ru/3.2/ref/models/instances/#django.db.models.Model.save "django.db.models.Model.save")метода модели .

- `pre_delete` и `post_delete`
	- Отправляется до или после [`delete()`](https://djangodoc.ru/3.2/ref/models/instances/#django.db.models.Model.delete "django.db.models.Model.delete") вызова [`delete()`](https://djangodoc.ru/3.2/ref/models/querysets/#django.db.models.query.QuerySet.delete "django.db.models.query.QuerySet.delete") метода модели или метода набора запросов .

- `m2m_changed`
	- Отправляется при изменении [`ManyToManyField`](https://djangodoc.ru/3.2/ref/models/fields/#django.db.models.ManyToManyField "django.db.models.ManyToManyField")модели.

- `request_started` и `request_finished`
	- Отправляется, когда Django запускает или завершает HTTP-запрос.

- [Полный список сигналов](https://djangodoc.ru/3.2/ref/signals/)

## Параметры Сигналов



# Пример использования

представим, что мы хотим зарегистрировать пользователя и после отправки формы, отправить письмо с подтверждением почты.

это можно сделать и обычными путями проходя долгий и тернистый путь

а можно поймать определенный сигнал, который посылает модель User в момент создания пользователя

```python 
from django.dispatch import receiver
from django.db.models.signals import post_save, pre_save

User = settings.AUTH_USER_MODEL

@receiver(post_save, sender=User)
def user_created(sender, instance, created, *args, **kwargs):
	if created: 
		print("Send email to", instance.user.username)
	else:
		print(instance.user.username, instance.id,  "was saved")

# post_save.connect(receiver=user_created, sender=MyModel)

@receiver(pre_save, sender=User)
def user_not_created(sender, instance, created, *args, **kwargs):
	print(instance.username, instance.id)
```
>в функции `user_not_created` поле - `id` еще не будет создано, 
>так что оно вернет нам None



Параметры функции
1. `sender` - откуда отправляется сигнал, в нашем случае это модель User
 2. `instance` - параметр содержащий массив данных объекта в виде словаря 
 3.  `created` - параметр принимает только булевые значения и зависят от сигнала 
	  - `post_save` -> `created = True`
	  - `pre_save` -> `created = False`


>[!danger] Важно
>вызов метода save(), внутри функции user_not_created может вызвать рекурсию, что приведет к утечкам памяти

```python
@receiver(pre_save, sender=User)
def user_not_created(sender, instance, created, *args, **kwargs):
	# активирует сигнал pre_save
	instance.save()
	# активирует сигнал post_save
```